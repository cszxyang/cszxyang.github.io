<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <title>
       聊聊多线程环境下的 HashMap &middot;  cszxyang
    </title>

    
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta property="og:title" content=" 聊聊多线程环境下的 HashMap &middot;  cszxyang" />
  	<meta property="og:site_name" content="cszxyang" />
  	<meta property="og:url" content="https://golb.cc/blog/2021/06/03/%E8%81%8A%E8%81%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84-hashmap/" />

    
  	<meta property="og:type" content="article" />
    <meta property="og:article:published_time" content="2021-06-03T10:54:24&#43;02:00" />
    
    <meta property="og:article:tag" content="技术" />
    
    <meta property="og:article:tag" content="Java" />
    
    <meta property="og:article:tag" content="hashmap" />
    
    <meta property="og:article:tag" content="源码" />
    
    

    <meta name="description" content="一路同步，静心记录。" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="https://golb.cc/images/favicon.ico">
	  <link rel="apple-touch-icon" href="https://golb.cc/images/apple-touch-icon.png" />
    <link rel="stylesheet" type="text/css" href="https://golb.cc/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="https://golb.cc/css/nav.css" />
    <link rel="stylesheet" type="text/css" href="https://golb.cc/css/hugo.css" />

    
    <link rel="stylesheet" type="text/css" href="https://golb.cc/css/highlight.css">
    <link rel="stylesheet" type="text/css" href="https://golb.cc/css/atom-one-dark.css">
    
    
    <script src="https://golb.cc/js/highlight.js"></script>
    <script type="text/javascript">hljs.initHighlightingOnLoad();</script>
   
    
   <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8ee45840325e1a8c8d1bdc689ea4d279";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
   </script>


    
    

    

    <link rel="canonical" href="https://golb.cc/blog/2021/06/03/%E8%81%8A%E8%81%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84-hashmap/" />

    
</head>
<body class="nav-closed">

  <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        

        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://golb.cc/">首页</a>
            </li>
        
            
            <li class="nav-opened" role="presentation">
            	<a href="https://golb.cc/about">关于</a>
            </li>
        

        <li class="nav-opened" role="presentation"><a href=""></a></li>
        <li class="nav-opened" role="presentation"><a href="https://golb.cc/tags/技术/">技术</a></li>
        <li class="nav-opened" role="presentation"><a href="https://golb.cc/tags/生活/">生活</a></li>
        <li class="nav-opened" role="presentation"><a href="https://golb.cc/tags/随想/">随想</a></li>
        <li class="nav-opened" role="presentation"><a href="https://golb.cc/tags/翻译/">翻译</a></li>
        <li class="nav-opened" role="presentation"><a href="https://golb.cc/tags/笔记/">笔记</a></li>
    </ul>

    
    

    
</div>
<span class="nav-cover"></span>


 <div class="site-wrapper">




  <header class="main-header post-head" style="background-image: url(https://www.bing.com/ImageResolution.aspx?w=1366&amp;h=768)">
  

    <nav class="main-nav overlay clearfix">
    
        
    
    
        <a class="menu-button" href="#"><span class="burger">&#9776;</span><span class="word">菜单</span></a>
    
</nav>

    <div class="vertical">
        <div class="main-header-content inner">
            <h1 class="page-title">聊聊多线程环境下的 HashMap</h1>
            <h2 class="page-description">cszxyang</h2> <br/>
            
    <a class="bloglogo" href="https://github.com/cszxyang" target="_blank">
    <span class="icon-github" style="color:white;font-size:2em"></span>
    </a>
&nbsp;






        </div>
    </div>
</header>



<main class="content" role="main">
  <article class="post post">

    <header class="post-header">
        <h1 class="post-title">聊聊多线程环境下的 HashMap</h1>
        

        <section class="post-meta">
        
          <span class="post-tag small"><a href="https://golb.cc/tags/%E6%8A%80%E6%9C%AF/">#技术</a>&nbsp;&nbsp;&nbsp;&nbsp;</span>
        
          <span class="post-tag small"><a href="https://golb.cc/tags/java/">#Java</a>&nbsp;&nbsp;&nbsp;&nbsp;</span>
        
          <span class="post-tag small"><a href="https://golb.cc/tags/hashmap/">#hashmap</a>&nbsp;&nbsp;&nbsp;&nbsp;</span>
        
          <span class="post-tag small"><a href="https://golb.cc/tags/%E6%BA%90%E7%A0%81/">#源码</a>&nbsp;&nbsp;&nbsp;&nbsp;</span>
        
        &nbsp;&nbsp;
        
          <time class="post-date" datetime="2021-06-03T10:54:24&#43;02:00">
            2021/6/3
          </time>
        
        </section>
        <br/>
    </header>

    <section class="post-content">
      <p>本文主要谈谈多线程环境下的 HashMap 可能存在的并发问题。</p>
<p>很久之前我写了这么一个并发异步的工具方法，传入的 <code>suppliers</code> 是具体的业务方法函数引用，考虑这个一个业务场景，我们需要去数据库统计某个表最近一个月在某个条件下的数量，那么为了提高响应效率，可以通过按天切分日期，然后组装成相应的 <code>supplier</code>，再通过多线程异步处理，最后统一收集完结果返回。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> Collection<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">supplyAsyncWithExpDeal</span><span style="color:#f92672">(</span>Collection<span style="color:#f92672">&lt;</span>Supplier<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;&gt;</span> suppliers<span style="color:#f92672">,</span>
                                                       <span style="color:#66d9ef">boolean</span> distinct<span style="color:#f92672">,</span> Executor executor<span style="color:#f92672">,</span> 
                                                       Function<span style="color:#f92672">&lt;</span>Throwable<span style="color:#f92672">,</span> R<span style="color:#f92672">&gt;</span> expHandler<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Collection<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> res <span style="color:#f92672">=</span> distinct <span style="color:#f92672">?</span> <span style="color:#66d9ef">new</span> HashSet<span style="color:#f92672">&lt;&gt;()</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>CollectionUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">isNotEmpty</span><span style="color:#f92672">(</span>suppliers<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">nonNull</span><span style="color:#f92672">(</span>executor<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
        log<span style="color:#f92672">.</span><span style="color:#a6e22e">info</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;FutureUtils.supplyAsync ==&gt; size of suppliers: {}&#34;</span><span style="color:#f92672">,</span> suppliers<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">());</span>
        <span style="color:#75715e">// wait for all tasks to finish
</span><span style="color:#75715e"></span>        CompletableFuture<span style="color:#f92672">.</span><span style="color:#a6e22e">allOf</span><span style="color:#f92672">(</span>suppliers<span style="color:#f92672">.</span><span style="color:#a6e22e">stream</span><span style="color:#f92672">().</span><span style="color:#a6e22e">filter</span><span style="color:#f92672">(</span>Objects<span style="color:#f92672">::</span>nonNull<span style="color:#f92672">).</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span>
            supplier <span style="color:#f92672">-&gt;</span>	CompletableFuture<span style="color:#f92672">.</span><span style="color:#a6e22e">supplyAsync</span><span style="color:#f92672">(</span>supplier<span style="color:#f92672">,</span> executor<span style="color:#f92672">).</span><span style="color:#a6e22e">thenApply</span><span style="color:#f92672">(</span>r <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>                                       <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">nonNull</span><span style="color:#f92672">(</span>r<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                    <span style="color:#75715e">// concurrent contending point
</span><span style="color:#75715e"></span>                    res<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>r<span style="color:#f92672">);</span>
        		<span style="color:#f92672">}</span>
        		<span style="color:#66d9ef">return</span> r<span style="color:#f92672">;</span>
            <span style="color:#f92672">}).</span><span style="color:#a6e22e">exceptionally</span><span style="color:#f92672">(</span>throwable <span style="color:#f92672">-&gt;</span> 
                R r <span style="color:#f92672">=</span> expHandler<span style="color:#f92672">.</span><span style="color:#a6e22e">apply</span><span style="color:#f92672">(</span>throwable<span style="color:#f92672">);</span>
                res<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>r<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">return</span> r<span style="color:#f92672">;</span>
          	<span style="color:#f92672">})).</span><span style="color:#a6e22e">toArray</span><span style="color:#f92672">(</span>CompletableFuture<span style="color:#f92672">[]</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">new</span><span style="color:#f92672">)).</span><span style="color:#a6e22e">join</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> res<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>最近有同事提醒我，收集结果的地方潜在并发问题，原来我的考虑是在一个方法里创建的变量是在栈里面的，所以多线程并发时，创建的 <code>res</code> 对象是不一样的，所以没有线程安全问题，但是 Java 8 的流式处理是基于多线程的，即后面在方法内部再分发任务到  <code>executor</code>  的工作线程（我没睡醒），由于此处使用的是线程不安全的集合类，所以 add 方法存在线程安全问题，解决方案是将问题行替换为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Collection<span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> res <span style="color:#f92672">=</span> distinct <span style="color:#f92672">?</span> <span style="color:#66d9ef">new</span> ConcurrentHashSet<span style="color:#f92672">&lt;&gt;()</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">new</span> CopyOnWriteArrayList<span style="color:#f92672">&lt;&gt;();</span>
</code></pre></div><p>其中因为 JDK 没有提供 ConcurrentHashSet 实现，此处的 ConcurrentHashSet 来自 hutool 工具包。</p>
<p>然而改完之后，合代码到生产环境时，我还是有点心虚，因为我不确定为什么这样改就能高枕无忧了，先不管 List，在千千万万的博客文章中，人人都说 HashMap、HashSet、ArrayList 等等不是线程安全的，要使用相应的 JUC 包下的工具类，面试时被问到 “HashMap 和 ConcurrentHashMao 的区别” 时一定要答 “HashMap 是线程安全的，ConcurrentHashMao  是非线程安全的”，那么，先不说 ConcurrentHashMao 是怎么保证线程安全的，HashMap 在多线程并发的场景下会有什么问题呢？有人说可能会出现死循环，可能会导致 CPU 100%，可能会导致丢数据，那么真的是那样吗？如果是，又是怎么出现的呢？实践出真知，我们不妨自己来试试一一验证，而不是人云亦云。</p>
<h3 id="一环境准备">一、环境准备</h3>
<p>为了模拟多线程并发的场景，我需要在源码中进行判断和控制，所以我需要能够随意地修改 HashMap 的源码，但是 JDK 是只读的，那么怎么办呢？简单，把源码及相关的依赖复制出来就行，因为人们都说 JDK 8 的 HashMap 对大部分问题进行了修复，尽管它还不是线程安全的。那我们就一步步来，先看看 1.7 版本中会有什么问题，所以我搞了个 <a href="https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html">jdk-7u80</a> 中的哈希表源码抠了出来，并进行了修改，它和一些测试代码组成的完整的工程可见 <a href="https://github.com/cszxyang/jdk7-test/tree/master/src/com/github/cszxyang/jt/util/map">这里</a>。</p>
<h3 id="二hashmap-的运作">二、<code>HashMap</code> 的运作</h3>
<p>JDK 1.7 中的 HashMap 采用数组作为哈希表，使用键值对节点头插成链的拉链法解决哈希冲突，当整个 HashMap 中的键值对节点超过一定阈值时，就会进行扩容，扩容的基本运作过程是，新建一个原哈希表数组双倍大小的新数组，然后（可选地）重新计算哈希值，再根据新的哈希值将节点复制到新的哈希表中，当然冲突链中的数据也通过头插法进行重新排布。</p>
<p>对于 put 方法，主要思路是：计算哈希值得到索引，判断是否发生哈希冲突，是则遍历链，如果能找到 key 对应的值，则进行更新，否则进行插入。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> putForNullKey<span style="color:#f92672">(</span>value<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> hash <span style="color:#f92672">=</span> hash<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> indexFor<span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> table<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">);</span>
    <span style="color:#75715e">// 如果 key 已经存在，则更新 value，并返回旧值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> table<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span> e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Object k<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">((</span>k <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>k<span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
            V oldValue <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
            e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
            e<span style="color:#f92672">.</span><span style="color:#a6e22e">recordAccess</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span> oldValue<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    modCount<span style="color:#f92672">++;</span>
    <span style="color:#75715e">// 如果 key不存在，则插入新的元素
</span><span style="color:#75715e"></span>    addEntry<span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> i<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>对于插入键值对，需要检查此时（不算上将要插入的节点）的节点数是否超过阈值，是则先进行扩容，再将新节点插到新的哈希表中。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addEntry</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> bucketIndex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>size <span style="color:#f92672">&gt;=</span> threshold<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">null</span> <span style="color:#f92672">!=</span> table<span style="color:#f92672">[</span>bucketIndex<span style="color:#f92672">]))</span> <span style="color:#f92672">{</span>
        resize<span style="color:#f92672">(</span>2 <span style="color:#f92672">*</span> table<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">);</span>
        hash <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">null</span> <span style="color:#f92672">!=</span> key<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> hash<span style="color:#f92672">(</span>key<span style="color:#f92672">)</span> <span style="color:#f92672">:</span> 0<span style="color:#f92672">;</span>
        bucketIndex <span style="color:#f92672">=</span> indexFor<span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> table<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    createEntry<span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> bucketIndex<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>对于扩容，先计算出新的数组的长度（原表长度的两倍）并创建新数组，然后将数据从原数组搬运过去。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">resize</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> newCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Entry<span style="color:#f92672">[]</span> oldTable <span style="color:#f92672">=</span> table<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> oldCapacity <span style="color:#f92672">=</span> oldTable<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">...</span>
    Entry<span style="color:#f92672">[]</span> newTable <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Entry<span style="color:#f92672">[</span>newCapacity<span style="color:#f92672">];</span>
    <span style="color:#f92672">...</span>
    transfer<span style="color:#f92672">(</span>newTable<span style="color:#f92672">,</span> rehash<span style="color:#f92672">);</span>
    table <span style="color:#f92672">=</span> newTable<span style="color:#f92672">;</span>
    threshold <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span>Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">*</span> loadFactor<span style="color:#f92672">,</span> MAXIMUM_CAPACITY <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>对于搬运数据，需要遍历原数组及冲突链，进行重新哈希（如果需要的话）得到新的下标，然后进行搬运，一样地使用头插法排布节点。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">transfer</span><span style="color:#f92672">(</span>Entry<span style="color:#f92672">[]</span> newTable<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> rehash<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> newCapacity <span style="color:#f92672">=</span> newTable<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">:</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span><span style="color:#66d9ef">null</span> <span style="color:#f92672">!=</span> e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> next <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>rehash<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">==</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span> <span style="color:#f92672">?</span> 0 <span style="color:#f92672">:</span> hash<span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> indexFor<span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">,</span> newCapacity<span style="color:#f92672">);</span>
            e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> newTable<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
            newTable<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
            e <span style="color:#f92672">=</span> next<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="三场景模拟">三、场景模拟</h3>
<p>很多人说多线程环境下哈希表的扩容操作并发时，会出现节点成环的情况，从而在 get 某个节点的时候出现死循环，但他们没有给出实际的 debug 过程，我们不妨来尝试模拟这种场景。</p>
<p>HashMap 的实时容量记为 size，扩容阈值为 threshold，如果 size &gt;= threshold，则进行扩容，其中 threshold = capacity * loadFactor，capacity 为用户指定的表大小，如果不指定则默认为 16，loadFactor 可理解为一个比例，即达到百分之多少进行扩容，默认地 loadFactor = 0.8，为了便于测试，我们将 capacity 设为 4，loadFactor 设为 1.0，并进行数据初始化。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">final</span> HashMap<span style="color:#f92672">&lt;</span>CustomKey<span style="color:#f92672">,</span> String<span style="color:#f92672">&gt;</span> map <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;(</span>4<span style="color:#f92672">,</span> 1<span style="color:#f92672">);</span>
<span style="color:#66d9ef">final</span> CustomKey k1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CustomKey<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">);</span>
CustomKey k2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CustomKey<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">);</span>
CustomKey k3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CustomKey<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;c&#34;</span><span style="color:#f92672">);</span>
<span style="color:#66d9ef">final</span> CustomKey k4 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CustomKey<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;d&#34;</span><span style="color:#f92672">);</span>
<span style="color:#66d9ef">final</span> CustomKey k5 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CustomKey<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;e&#34;</span><span style="color:#f92672">);</span>
map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>k1<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;aa&#34;</span><span style="color:#f92672">);</span>
map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>k2<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;bb&#34;</span><span style="color:#f92672">);</span>
map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>k3<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;cc&#34;</span><span style="color:#f92672">);</span>
map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>k4<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;dd&#34;</span><span style="color:#f92672">);</span>

<span style="color:#66d9ef">final</span> HashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>CustomKey<span style="color:#f92672">,</span> String<span style="color:#f92672">&gt;[]</span> table <span style="color:#f92672">=</span> map<span style="color:#f92672">.</span><span style="color:#a6e22e">table</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>HashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>CustomKey<span style="color:#f92672">,</span> String<span style="color:#f92672">&gt;</span> customKeyStringEntry <span style="color:#f92672">:</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>customKeyStringEntry<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>其中，CustomKey 是我自定义的一个类，作为键值对的键对象。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomKey</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> hashCode<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> String uid<span style="color:#f92672">;</span>
    
	<span style="color:#75715e">// constructors...
</span><span style="color:#75715e"></span>    
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> hashCode<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object o<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> o<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>o <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> getClass<span style="color:#f92672">()</span> <span style="color:#f92672">!=</span> o<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">())</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        CustomKey customKey <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>CustomKey<span style="color:#f92672">)</span> o<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>uid<span style="color:#f92672">,</span> customKey<span style="color:#f92672">.</span><span style="color:#a6e22e">uid</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">toString</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> uid<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>不得不提的是，HashMap 的哈希函数如下所示，很显然这个算法是跟对象的 hashCode 有关的，所以为了模拟哈希冲突，我需要能够控制每个测试对象的 hashCode，所以将之作为类的属性之一。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hash</span><span style="color:#f92672">(</span>Object k<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> hashSeed<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>0 <span style="color:#f92672">!=</span> h <span style="color:#f92672">&amp;&amp;</span> k <span style="color:#66d9ef">instanceof</span> String<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> sun<span style="color:#f92672">.</span><span style="color:#a6e22e">misc</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Hashing</span><span style="color:#f92672">.</span><span style="color:#a6e22e">stringHash32</span><span style="color:#f92672">((</span>String<span style="color:#f92672">)</span> k<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    h <span style="color:#f92672">^=</span> k<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">();</span>

    <span style="color:#75715e">// This function ensures that hashCodes that differ only by
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// constant multiples at each bit position have a bounded
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// number of collisions (approximately 8 at default load factor).
</span><span style="color:#75715e"></span>    h <span style="color:#f92672">^=</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 20<span style="color:#f92672">)</span> <span style="color:#f92672">^</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 12<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> h <span style="color:#f92672">^</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 7<span style="color:#f92672">)</span> <span style="color:#f92672">^</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 4<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>另外，结合前面的 <code>put</code> 函数，如果 <code>e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))</code>，则认为该键对象已经存在，而不是认为发生哈希冲突，所以我还需够重写 equals 方法，</p>
<p>因为默认地，所有对象的 equals 都继承自 Object 中的 equals 方法（比对堆地址），所以，如果一个类重写了 equals 方法，通过类的属性组合而不是地址作为对象的唯一性特征（即如果两个对象的各项特性一样，那么我们认为它们是 equals 的）时，那么新增元素会按照各个属性维度判断键值对是否已经存在，从而不往其中插入键一样的键值对，我们重写了 equals，那么往往还需要重写 hashCode 方法，通过对象的各个特性计算 hashCode，因为前面的 <code>e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))</code> 判断才会认为两个属性相同的对象可认为同一对象。总有人说，如果重写了类的 equals 方法，一定要重写 hashCode 方法，但是倘若这个类的对象不作为哈希表的键，那么这个所谓的 “准测” 看起来让人觉得十二分莫名其妙。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object obj<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> obj<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>按照上面的理解，我们的 hashCode 方法应该由对象的各个属性决定的，但是为了模拟哈希冲突，我故意为多个对象设置了一样的 hashCode，让它们排成一条链表。为了便于观察，我重写了 <code>HashMap.Entry </code> 的 toString 方法，对冲突链进行格式化。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Override</span>
<span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">toString</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    StringBuilder res <span style="color:#f92672">=</span>  <span style="color:#66d9ef">new</span> StringBuilder<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;{&#34;</span> <span style="color:#f92672">+</span> key <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, &#34;</span> <span style="color:#f92672">+</span> value <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, &#34;</span> <span style="color:#f92672">+</span> hash <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;}&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>next <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        res<span style="color:#f92672">.</span><span style="color:#a6e22e">append</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34; -&gt; &#34;</span><span style="color:#f92672">);</span>
        res<span style="color:#f92672">.</span><span style="color:#a6e22e">append</span><span style="color:#f92672">(</span>next<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">());</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> res<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>看下上面我们构建的哈希表输出：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">null</span>
<span style="color:#f92672">{</span>d<span style="color:#f92672">,</span> dd<span style="color:#f92672">,</span> 1<span style="color:#f92672">}</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>c<span style="color:#f92672">,</span> cc<span style="color:#f92672">,</span> 1<span style="color:#f92672">}</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>b<span style="color:#f92672">,</span> bb<span style="color:#f92672">,</span> 1<span style="color:#f92672">}</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>a<span style="color:#f92672">,</span> aa<span style="color:#f92672">,</span> 1<span style="color:#f92672">}</span>
<span style="color:#66d9ef">null</span>
<span style="color:#66d9ef">null</span>
</code></pre></div><p>现在整个哈希表的数据状态大致如下所示：</p>
<p><img src="https://golb.cc/images/java/jdk/hashmap/Snipaste_2021-06-03_11-35-42.png" alt="Snipaste_2021-06-03_11-35-42.png"></p>
<p>由于扩容阈值是 4，所以当我们再尝试往其中添加一个 hash 到 1 号桶下标的键值对 {e, ee} 的时候，将会触发扩容，倘若正巧有多个线程在扩容操作中并发，那么会发生什么呢？我们假设现在有两条线程并发插入一个键值对到同一位置，触发扩容。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Thread t1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        ThreadUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
        map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>k5<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;ee&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">});</span>
t1<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;T1&#34;</span><span style="color:#f92672">);</span>
Thread t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>k5<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;ee&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">});</span>
t2<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;T2&#34;</span><span style="color:#f92672">);</span>
t2<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
t1<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</code></pre></div><h3 id="四分析与测试">四、分析与测试</h3>
<p>对于上面的场景，假设在 t1 时间点，线程 T2 进入扩容方法，它创建了一个新的数组，并尝试将旧数组中的数据搬运到新数组中，此时其时间片用完，上下文切换到另一个线程 T1。</p>
<p><img src="https://golb.cc/images/java/jdk/hashmap/Snipaste_2021-06-03_11-47-37.png" alt="Snipaste_2021-06-03_11-47-37.png"></p>
<p>为了模拟线程 T2 用完时间片，我们在它遍历 {d, dd} 这个节点的时候让它陷入休眠，注意此时它的栈空间中持有了 e 和 next 句柄指向。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">transfer</span><span style="color:#f92672">(</span>Entry<span style="color:#f92672">[]</span> newTable<span style="color:#f92672">,</span> <span style="color:#66d9ef">boolean</span> rehash<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> newCapacity <span style="color:#f92672">=</span> newTable<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">:</span> table<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span><span style="color:#66d9ef">null</span> <span style="color:#f92672">!=</span> e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> next <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
            <span style="color:#75715e">// 线程 2 陷入此处，e = dd，next = cc
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>cnt <span style="color:#f92672">==</span> 0  <span style="color:#f92672">&amp;&amp;</span> <span style="color:#e6db74">&#34;T2&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">())</span> <span style="color:#f92672">&amp;&amp;</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;T2进入休眠&#34;</span><span style="color:#f92672">);</span>
                ThreadUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>2<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>rehash<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">==</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span> <span style="color:#f92672">?</span> 0 <span style="color:#f92672">:</span> hash<span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> indexFor<span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">,</span> newCapacity<span style="color:#f92672">);</span>
            e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> newTable<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
            newTable<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
            e <span style="color:#f92672">=</span> next<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>接下来在 t2 时间段内，线程 T1 尝试放入  {e, ee}，同样地也会触发扩容，在 resize 方法中创建自己的新数组，然后进行数据搬运，让我们来看看数据搬运的过程：</p>
<p>在遍历过程中，首先 e 和 next 分别指向 {d, dd} 和 {c, cc} 节点，然后 {d, dd} 和 {c, cc} 间的指针断开，{d, dd} 被拷贝到了新数组上，e 指针向前移动。</p>
<p><img src="https://golb.cc/images/java/jdk/hashmap/Snipaste_2021-06-03_12-43-36.png" alt="Snipaste_2021-06-03_12-43-36.png"></p>
<p>经过多轮迭代，最后两个数组的情况如下所示：</p>
<p><img src="https://golb.cc/images/java/jdk/hashmap/Snipaste_2021-06-03_12-50-03.png" alt="Snipaste_2021-06-03_12-50-03.png"></p>
<p>假设在此时开始的 t3 时间内，线程 T1 失去时间片，线程 T2 苏醒并继续它未完成的任务，我们在 table 赋值的地方对线程 T1 进行休眠处理：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">resize</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> newCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Entry<span style="color:#f92672">[]</span> oldTable <span style="color:#f92672">=</span> table<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> oldCapacity <span style="color:#f92672">=</span> oldTable<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>oldCapacity <span style="color:#f92672">==</span> MAXIMUM_CAPACITY<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        threshold <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    Entry<span style="color:#f92672">[]</span> newTable <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Entry<span style="color:#f92672">[</span>newCapacity<span style="color:#f92672">];</span>
    transfer<span style="color:#f92672">(</span>newTable<span style="color:#f92672">,</span> initHashSeedAsNeeded<span style="color:#f92672">(</span>newCapacity<span style="color:#f92672">));</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;T1&#34;</span><span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()))</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;T1进入休眠&#34;</span><span style="color:#f92672">);</span>
        ThreadUtils<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>6<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    table <span style="color:#f92672">=</span> newTable<span style="color:#f92672">;</span>
    threshold <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span>Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">*</span> loadFactor<span style="color:#f92672">,</span> MAXIMUM_CAPACITY <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>前面我们提到，线程 T2 已经持有了自己 e 和 next 句柄，分别指向 {d, dd} 和 {c, cc} 节点，但是由于线程  T1 在数据搬运过程中颠覆了整条链的指针指向情况，尽管数据搬运是一个拷贝过程，但是拷贝也分为深拷贝和浅拷贝，此处的拷贝属于浅拷贝！所以此时对于线程 T2 来说，它看到的情况是这样的：</p>
<p><img src="https://golb.cc/images/java/jdk/hashmap/Snipaste_2021-06-03_13-00-49.png" alt="Snipaste_2021-06-03_13-00-49.png"></p>
<p>然后它尝试进行搬运，{d, dd} 被浅拷贝到新数组的下标为 1 的桶口，e 指向 next 记录的 {c, cc} 节点，而在下一个循环的开始时，next 指向原 {c, cc} 的下一个节点，因为是引用指向，所以 next 指向了线程 T1 中的新数组中的冲突链表记录的 {d, dd} 节点。</p>
<p><img src="https://golb.cc/images/java/jdk/hashmap/Snipaste_2021-06-03_13-57-31.png" alt="img"></p>
<p>于是 {c, cc} 节点理所当然地被头插到 1 号桶口，其 next 指针指向了 {d, dd} 节点，接下来，e 指向了原局部变量 next 指向的 {d, dd}，下一次迭代进来会尝试将 {d, dd} 头插到 {c, cc} 前面，而 {c, cc} 的 next 指针已经指向了 {d, dd}，从而出现了循环引用的情况，试想如果此时线程 T2 调用 get 方法，那么将会触发死循环。</p>
<p><img src="https://golb.cc/images/java/jdk/hashmap/Snipaste_2021-06-03_14-02-34.png" alt="Snipaste_2021-06-03_14-02-34.png"></p>
<p>我们尝试在线程 T2 中调用 get 方法进行测试：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Thread t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>k5<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;ee&#34;</span><span style="color:#f92672">);</span>
        map<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>k1<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">});</span>
</code></pre></div><p>为了结果直观化，我尝试将运行过程做成了 gif，看着还挺好玩。结果也很明显，的确出现了死循环。</p>
<p><img src="https://golb.cc/images/java/jdk/hashmap/deadloop.gif" alt="deadloop.gif"></p>
<p>与此同时，我们打开任务管理器查看 CPU 运行情况，可以看到 CPU 利用率已经去到了 100%，把程序停掉后恢复正常。</p>
<p><img src="https://golb.cc/images/java/jdk/hashmap/Snipaste_2021-06-03_15-00-43.png" alt="Snipaste_2021-06-03_15-00-43.png"></p>
<blockquote>
<p>如果线上环境出现 CPU 利用飙升的情况，对于 Windows服务器，通过 <code>tasklist</code> 命令拿到 JVM 的 PID，</p>
<p><img src="https://golb.cc/images/java/jdk/hashmap/Snipaste_2021-06-03_17-53-30.png" alt="img"></p>
<p>然后使用 jstack 查看线程运行情况，然后定位到具体的代码位置。</p>
<p><img src="https://golb.cc/images/java/jdk/hashmap/Snipaste_2021-06-03_17-47-49.png" alt="Snipaste_2021-06-03_17-47-49.png"></p>
<p>对于 Linux 服务器，可以使用 <code>top -p 265 -H</code> 命令查看 CPU 占用率高的进程，如果是 JVM 进程，拿到其 10 进制的 pid，然后通过 <code>printf &quot;%x&quot; xx</code> 转成十六进制，再使用 jstack 查看线程运行状况。</p>
</blockquote>
<p>试想如果极端一点，某个系统的并发量极高，同一时刻有 100 条像 T2 这样的线程在成环的冲突链表上调用 get 方法，那么服务的可用性将会受到极大的威胁。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 102<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
    Thread t2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#a6e22e">@Override</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
            map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>k5<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;ee&#34;</span><span style="color:#f92672">);</span>
            map<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>k1<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">});</span>
    t2<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;T&#34;</span> <span style="color:#f92672">+</span> i<span style="color:#f92672">);</span>
    t2<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="五总结">五、总结</h3>
<p>JDK 1.7 版本的 HashMap 由于没有做同步控制（事实上，它的设计初衷本身不是用于并发场景），所以需要避免在多线程环境下使用它来存储数据，因为在多线程并发扩容的时候，由于采用头插法及浅拷贝，会导致数据丢失及节点循环引用的情况，从而在后续调用 get 方法时触发死循环。</p>
    </section>

    <footer class="post-footer">
      
        <figure class="author-image">
            <a class="img" href="https://golb.cc/" style="background-image: url(https://golb.cc/images/logo-cogi.gif)"><span class="hidden">cszxyang's Picture</span></a>
        </figure>
      

      





<section class="author" style="width:100%;">
  <div class="author-meta" style="width:100%;text-align:center;">
    <span class="author-location icon-user"> A shell picker</span>
    <span class="author-location icon-location"> Guangzhou, China</span>
    <span class="author-link icon-link"><a href="https://cszxyang.github.io/"> https://cszxyang.github.io/</a></span>
    

    
  </div>
  <br/>
</section>


      
        <aside class="read-next">
  

  
      <span class="readmore-next readmore-meta">NEXT: <a href="https://golb.cc/blog/2021/05/14/%E6%B5%85%E8%B0%88-mysql-%E7%9A%84-mvcc-%E6%9C%BA%E5%88%B6/"><h4>浅谈 MySQL 的 MVCC 机制</h4></a></span>
      
  
</aside>
<br/>

      
      
      

	
	<div id="lv-container" data-id="city" data-uid="MTAyMC81MDQ0OC8yNjkzNQ==">
		<script type="text/javascript">
	   (function(d, s) {
	       var j, e = d.getElementsByTagName(s)[0];

	       if (typeof LivereTower === 'function') { return; }

	       j = d.createElement(s);
	       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
	       j.async = true;

	       e.parentNode.insertBefore(j, e);
	   })(document, 'script');
		</script>
	<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
	</div>
	

	


    </footer>
</article>

</main>

    <footer class="site-footer clearfix">
        <a id="gotop" class="icon-arrow-up" href="#" title="back to top"></a>

        <section class="copyright"><a href="">cszxyang. </a> All rights reserved &copy; 2018 - 2020</section>
        
        <section class="poweredby">Proudly generated by <a href="http://gohugo.io">HUGO</a>, with <a class="icon-theme" href="https://github.com/vjeantet/hugo-theme-casper">Casper</a> theme &nbsp;
          <span id="cnzz_stat_icon_1000165127">
            <a href="https://tongji.baidu.com/web/10000135732/trend/latest?siteId=15190378" target="_blank" title="站长统计">
              <img border="0" hspace="0" vspace="0" src="http://icon.cnzz.com/img/pic1.gif">
            </a>
          </span>
        </section>
        
    </footer>
  </div> 
    <script type="text/javascript" src="https://golb.cc/js/jquery.js"></script>
    <script type="text/javascript" src="https://golb.cc/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://golb.cc/js/index.js"></script>

    
    
    
    

    
</body>
</html>

